package Massband.com;

import android.hardware.*;

public class BerechnungWeg implements SchrittMessung{
    /* Messung mittels Integration Beschleunigungssensor */

    /** Anzahl Messungen werden jeweils gemittelt **/
    private final int AnzahlMess = 10;

    private KalibrierungMessung kalibrierung; 
    private MassbandGui GuiInterface;
    /** Buffer fuer Beschleunigungswerte **/
    private Buffer[];
    /** Historie Buffer **/
    private LetzterBuffer[];
    /** Anzahl Messung **/
    private int zaehler;
    /** Kalibrierungsfunktionen **/
    private mass Berechnungsfunktionen;
    /** Distanz **/
    private float Distance[];
    /** nur zur Berechnung Distanz **/
    private float PartDistance[];
    /** Zeit in Summe **/
    private float SumTime;
    /** Zeit seit letzter Berechnung  **/
    private float LetzteSumTime;

    public BerechnungWeg(KalibrierungMessung kalibrierung, MassbandGui gui){
	/* */
	this.kalibrierung = kalibrierung;
	this.ErsteMessung = true;
	this.GuiInterface = gui;
	LetzteMessung = new float[3];
	Buffer = new float[3];
	LetzterBuffer = new float[3];
	Distance = new float[4];
	PartDistance = new float[3];
    }
    
    @Override
    public boolean OnSensorChanged(SensorEvent event) throws RuntimeException{
	/* Sensor-Werte eines Sensors haben sich geaendert */
	switch(event.sensor.getType()){
	case Sensor.TYPE_ACCELEROMETER:
	    return AcceleroMeterChanged(event);
	case Sensor.TYPE_GYROSCOPE:
	    return GyroScopeChanged(event);
	default:
	    throws RuntimeException(); //unbekannter Sensor
	}

	
    }

    private boolean AcceleroMeterChanged(SensorEvent event) throws RuntimeException{
	/* Sensor-Werte des Accelerometers haben sich geaendert */
	if(!ErsteMessung){	    
	    for(int i=0;i<Buffer.length;i++){
		Buffer[i] += (LetzteMessung[i] + event.values[i])*(evt.timestamp - TimeStamp);
		
	    }
	    TimeStamp = evt.timestamp;
	}else{
	    TimeStamp = evt.timestamp;
	    ErsteMessung = false;
	    TimeStampBegin = evt.timestamp;
	}
	LetzteSumTime = evt.timestamp - TimeStamp;
	LetzteMessung = event.values;
	zaehler++;
	if(zaehler % AnzahlMess == 0 && !ErsteMessung){
	    /* Mittelwert aus den Buffer-Werten bilden */
	    for(int i=0;i<Buffer.length;i++){
		Buffer[i] = Buffer[i]/(2*(TimeStamp - TimeStampBeginn)) + kalibrierung.add[i];
	    }
	    newDirection(Buffer);
	    TimeStampBegin = TimeStamp;
	    Buffer = new float[3];
	}
    }
    private void NewDirection(float[] values) throws RuntimException{
	/* Neuen Weg berechnen, dazu die Beschleunigungswerte
	 zweimal integrieren */	
	float GlobalValues[] = kalibrierung.beschl(values); // Umrechnen lokale in globale Beschleunigung
	for(int i=0;i<DistancePart.length;i++){
	    SumTime += LetzteSumTime;
	    PartDistance[i] = (LetzterBuffer[i]*(SumTime-LetzteSumTime) + Buffer[i]*SumTime)* LetzteSumTime;
	
	
    }
    
}